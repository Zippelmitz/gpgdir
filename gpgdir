#!/usr/bin/perl -w
#
###########################################################################
#
# File: gpgdir
#
# Purpose:  To encrypt/decrypt whole directories
#
# Author: Michael B. Rash <mbr@ciphedyne.com>
#
# Version: 0.1
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
###########################################################################
#
# $Id$
#

use File::Find;
use File::Copy;
use Term::ReadKey;
use GnuPG;
use Getopt::Long;
use Cwd;
use strict;

#==================== config =======================
#my $gpg_homedir  = '/home/mbr/.gnupg';
#my $encrypt_user = 'A742839F';  ### mbr 2048 bit key

### system binaries
my $gunzipCmd = '/usr/bin/gunzip';
my $gzipCmd   = '/usr/bin/gzip';
#================== end config =====================

### establish some defaults
my $encrypt_user;
my $gpg_homedir;
my $dir;
my @subdirs;
my $pw;
my $encrypt;
my $encrypt_dir;
my $decrypt_dir;
my $total_encrypted = 0;
my $total_decrypted = 0;
my $norecurse       = 0;
my $nocompress      = 0;
my $help;

open STDERR, ">&STDOUT" || die ' ... @@@ Could not dup STDERR to STDOUT';

unless ($< == $>) {
    print " ... @@@ Real and effective uid must be the same.  Make sure\n";
    print "         gpgdir has not been installed as a SUID binary.\n";
    die "Exiting.\n";
}

### get the path to the .gnupg directory in the user's home directory
my $homedir = &get_homedir();
if (-d "${homedir}/.gnupg") {
    $gpg_homedir = "${homedir}/.gnupg";
} else {
    print " ... @@@ GPG directory: ${homedir}/.gnupg does not exist.  Please\n";
    print "         create it by executing: \"gpg --gen-key\".  Exiting.\n";
    exit 1;
}

### get the key identifier from ~/.gnupg
$encrypt_user = &get_key();

&usage_and_exit() unless(GetOptions (
    'encrypt=s'  => \$encrypt_dir,  ### encrypt files in this directory
    'decrypt=s'  => \$decrypt_dir,  ### decrypt files in this directory
    'norecurse'  => \$norecurse,    ### don't encrypt/decrypt files in subdirectories
    'nocompress' => \$nocompress,   ### don't compress files
    'help'       => \$help
));
&usage_and_exit() if $help;

if ($decrypt_dir && $encrypt_dir) {
    die " ... @@@ You cannot encrypt and decrypt the same directory.\n";
    &usage_and_exit();
}

unless ($decrypt_dir || $encrypt_dir) {
    print " ... @@@ Please specify a directory to encrypt or decrypt.\n";
    &usage_and_exit();
}

my $gpg = new GnuPG(homedir=>$gpg_homedir);

die " ... @@@ Could not create new gpg object with " .
    "homedir: $gpg_homedir" unless $gpg;

if ($encrypt_dir) {
    $dir = $encrypt_dir;
    $dir =~ s|/$||;  ### remove any trailing slash
    $encrypt = 1;
} elsif ($decrypt_dir) {
    ### get the password without echoing the chars back to the screen
    $dir = $decrypt_dir;
    $dir =~ s|/$||;  ### remove any trailing slash
    ReadMode 'noecho';
    while (! $pw) {
        print localtime() . " ... Enter a password to decrypt $dir: ";
        $pw = ReadLine 0;
        chomp $pw;
    }
    ReadMode 'normal';
    print "\n";
    $encrypt = 0;
}

my $initial_dir = cwd;

if ($dir !~ m|^/|) {
    $dir = $initial_dir . '/' . $dir;
}

unless ($norecurse) {
    ### find all subdirectories of $dir
    find(\&find_subdirs, $dir);
    for my $subdir (@subdirs) {
        ### perform the encrypt/decrypt operation on the directory
        &gpg_operation($subdir);
    }
} else {
    ### perform the encrypt/decrypt operation on the directory
    &gpg_operation($dir);
}

if ($encrypt) {
    print localtime() . " ... Total number of files encrypted: " .
        "$total_encrypted\n";
} else {
    print localtime() . " ... Total number of files decrypted: " .
        "$total_decrypted\n";
}
print localtime() . " ... Finished.\n";

exit 0;
#==================== end main =====================
sub gpg_operation() {
    my $dir = shift;
    my @errs;
    die " ... Directory: $dir does not exist.\n" unless -d $dir;

    if ($dir =~ m|\.gnupg|) {  ### don't encrypt any .gnupg directories!!!
        print localtime() . " ... @@@ Skipping directory: $dir\n";
        return;
    }
    chdir $dir or die " ... @@@ Could not chdir: $dir\n";
    opendir D, '.' or die "Could not open $dir";
    my @files = readdir D;
    closedir D;

    shift @files; shift @files;

    my $longest_filename = 0;
    for my $file (@files) {
        $longest_filename = length $file if (length $file > $longest_filename);
    }

    if ($encrypt) {
        $longest_filename += 5;
        print localtime() . " ... Directory: $dir ==> Encrypting <==\n";
    } else {
        print localtime() . " ... Directory: $dir ==> Decrypting <==\n";
    }

    FILE: for my $file (@files) {
        next FILE unless $file =~ /\S/ && -e $file;
        if ($encrypt) {
            ### don't encrypt files that are already
            ### encrypted, and make sure they exist
            if (-l $file) {
                push @errs, localtime() . " ... @@@ Skipping " .
                    "link: $file\n";
            } elsif (-s $file == 0) {
                push @errs, localtime() . " ... @@@ Skipping " .
                    "zero byte file: $file\n";
            ### NOTE: encrypted files cannot be modified, so go ahead and
            ### encrypt $file over any existing $file.gpg encrypted file.
            } elsif (! -d $file && $file =~ /\.gpg$/) {
                push @errs, localtime() . " ... @@@ Skipping " .
                    "encrypted file: $file\n";
            } elsif (! -d $file) {
                my $compressed = 0;
                if ($file =~ m|^\.|) {  ### don't encrypt hidden files
                    push @errs, localtime() . " ... @@@ Skipping " .
                        "hidden file: $file\n";
                    next FILE;
                }
                unless ($nocompress) {
                    unless ($file =~ m|\.gz$|) {
                        print localtime() . " ... Compressing " .
                            sprintf("%${longest_filename}s", $file) .
                                " -> ${file}.gz\n";
                        system "$gzipCmd $file";
                        if (-e "${file}.gz") {
                            move "${file}.gz", "${file}.gz_C";
                            $file = "${file}.gz_C";
                            $compressed = 1;
                        } else {
                            push @errs, localtime() . " ... @@@ Could not " .
                                "compress: $file\n";
                            next FILE;
                        }
                    }
                }
                print localtime() . " ... Encrypting  " .
                    sprintf("%${longest_filename}s", $file) .
                        " -> ${file}.gpg\n";
                $gpg->encrypt(plaintext=>$file, output=>"${file}.gpg",
                              recipient=>$encrypt_user);
                if (-e "${file}.gpg" && -s "${file}.gpg" != 0) {
                    $total_encrypted++;
                    ### only delete the original file if
                    ### the encrypted one exists
                    unlink $file;
                } else {
                    push @errs, localtime() . " ... @@@ Could not " .
                        "encrypt: $file\n";
                }
            }
        } else {
            my ($filename) = ($file =~ /^(\S+)\.gpg/);
            if (-l $file) {
                push @errs, localtime() . " ... @@@ Skipping " .
                    "link: $file\n";
            } elsif (-s $file == 0) {
                push @errs, localtime() . " ... @@@ Skipping zero byte " .
                    "file: $file\n";
            } elsif ($file !~ /\.gpg$/) {
                if (! -d $file) {
                    push @errs, localtime() . " ... @@@ Skipping " .
                        "decrypted file: $file\n";
                }
            } elsif (-e $filename) {
                push @errs, localtime() . " ... @@@ Skipping file: $file since " .
                    "the decrypted file: $filename already exists.\n";
            } elsif (! -d $file) {
                my $cfile;
                my $decompress = 0;
                if ($filename =~ /(\S+)_C$/) {  ### the file was compressed
                    $cfile = $1;
                    if (-e $cfile) {
                        push @errs, localtime() . " ... @@@ Skipping file: " .
                            "$file since $cfile already exists.\n";
                        next FILE;
                    } else {
                        $decompress = 1;
                    }
                }
                ### don't decrypt a file on top of a normal file of
                ### the same name
                print localtime() . " ... Decrypting    " .
                    sprintf("%${longest_filename}s", $file) .
                        " -> $filename\n";
                $gpg->decrypt(ciphertext=>$file, output=>$filename,
                              passphrase=>$pw);
                if (-e $filename && -s $filename != 0) {
                    $total_decrypted++;
                    ### only delete the original encrypted
                    ### file if the decrypted one exists
                    unlink $file;
                    if ($decompress) {
                        my ($ufile) = ($cfile =~ /(\S+)\.gz/);
                        print localtime() . " ... Uncompressing " .
                            sprintf("%${longest_filename}s", $cfile) .
                                " -> $ufile\n";
                        move $filename, $cfile;
                        system "$gunzipCmd $cfile";
                        unless (-e $ufile) {
                            push @errs, localtime() . " ... @@@ Could not " .
                                "uncompress: $cfile\n";
                        }
                    }
                } else {
                    push @errs, localtime() . " ... @@@ Could not " .
                        "decrypt: $file\n";
                }
            }
        }
    }
    if (@errs) {
        print localtime() . " ... Errors/Warnings:\n";
        ### print any errors
        for my $err (@errs) {
            print $err;
        }
    }
    chdir $initial_dir or die " ... @@@ Could not chdir: $initial_dir\n";
    return;
}

sub get_homedir() {
    my $uid = $<;
    open P, "< /etc/passwd" or die " ... @@@ Could not open /etc/passwd.  " .
        "Exiting.\n";
    my @lines = <P>;
    close P;
    my $homedir = '';
    for my $line (@lines) {
        ### mbr:x:222:222:Michael Rash:/home/mbr:/bin/bash
        chomp $line;
        if ($line =~ /^(?:.*:){2}$uid:(?:.*:){2}(\S+):/) {
            $homedir = $1;
            last;
        }
    }
    die " ... @@@ Could not extract homedir from /etc/passwd for " .
        "uid: $uid.  Exiting.\n" unless $homedir;
    die " ... @@@ homedir: $homedir does not exist.  " .
        "Exiting.\n" unless -d $homedir;
    return $homedir;
}

sub get_key() {
    if (-e "${homedir}/.gpgdirrc") {
        open F, "< ${homedir}/.gpgdirrc" or die " ... Could not open " .
            "${homedir}/.gpgdirrc.  Exiting.\n";
        my @lines = <F>;
        close F;
        my $key = '';
        for my $line (@lines) {
            chomp $line;
            if ($line =~ /^use_key\s+(.*)$/) {
                $key = $1;
                last;
            }
        }
        if ($key && $key =~ /\S/) {
            return $key;
        } else {
            print " ... @@@ Please edit ${homedir}/.gpgdirrc to include " .
                "your gpg key identifier.  Exiting.\n";
            exit 1;
        }
    } else {
        print " ... Creating gpgdir rc file: ${homedir}/.gpgdirrc\n";
        open F, "> ${homedir}/.gpgdirrc" or die " ... Could not open " .
            "${homedir}/.gpgdirrc.  Exiting.\n";
        print F "# Config file for gpgdir.\n";
        print F "# Set the key to use to encrypt files with\n";
        print F "# \"use_key <key>\", e.g. \"use_key A742839F\".\n";
        print F "# See \"gpg --list-keys\" for a list of keys.\n";
        print F "\n";
        close F;
        print " ... @@@ Please edit ${homedir}/.gpgdirrc to include " .
            "your gpg key identifier.  Exiting.\n";
        exit 1;
    }
    return;
}

sub find_subdirs() {
    my $file = $File::Find::name;
    if (-d $file && -e $file) {
        push @subdirs, $file;
    }
    return;
}

sub usage_and_exit() {
    print "gpgdir usage:\n";
    print "   --encrypt <directory>\n";
    print "   --decrypt <directory>\n";
    print "   --norecurse            - Don't encrypt/decrypt subdirectories\n";
    exit 0;
}
