#!/usr/bin/perl -w
#
###########################################################################
#
# File: gpgdir
#
# Purpose:  To encrypt/decrypt whole directories
#
# Author: Michael B. Rash (mbr@ciphedyne.com)
#
# Version: 0.2
#
# License (GNU General Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
###########################################################################
#
# $Id$
#

use File::Find;
use File::Copy;
use Term::ReadKey;
use GnuPG;
use Getopt::Long;
use Cwd;
use strict;

#==================== config =======================
my $version = '0.2';

### system binaries
my $gunzipCmd = '/usr/bin/gunzip';
my $gzipCmd   = '/usr/bin/gzip';
#================== end config =====================

### establish some defaults
my $encrypt_user;
my $gpg_homedir;
my $dir;
my @subdirs;
my $pw;
my $encrypt;
my $encrypt_dir;
my $decrypt_dir;
my $total_encrypted = 0;
my $total_decrypted = 0;
my $norecurse       = 0;
my $compress        = 0;
my $uncompress      = 0;
my $printver        = 0;
my $no_delete       = 0;
my $help;

open STDERR, ">&STDOUT" || die ' ** Could not dup STDERR to STDOUT';

unless ($< == $>) {
    print " ** Real and effective uid must be the same.  Make sure\n";
    print "    gpgdir has not been installed as a SUID binary.\n";
    die "Exiting.\n";
}

die " ** gzip is not located at: $gzipCmd.  Edit " .
    "the gpgdir config section." unless -e $gzipCmd;
die " ** $gzipCmd is not executable.  Use chmod to " .
    "make it executable." unless -x $gzipCmd;
die " ** gunzip is not located at: $gunzipCmd.  Edit " .
    "the gpgdir config section." unless -e $gunzipCmd;
die " ** $gunzipCmd is not executable.  Use chmod to " .
    "make it executable." unless -x $gunzipCmd;

### get the path to the .gnupg directory in the user's home directory
my $homedir = &get_homedir();
if (-d "${homedir}/.gnupg") {
    $gpg_homedir = "${homedir}/.gnupg";
} else {
    print " ** GPG directory: ${homedir}/.gnupg does not exist.  Please\n";
    print "    create it by executing: \"gpg --gen-key\".  Exiting.\n";
    exit 1;
}

### get the key identifier from ~/.gnupg
$encrypt_user = &get_key();

&usage_and_exit() unless(GetOptions (
    'encrypt=s'  => \$encrypt_dir,  # Encrypt files in this directory.
    'decrypt=s'  => \$decrypt_dir,  # Decrypt files in this directory.
    'compress'   => \$compress,     # Compress files (encrypt phase).
    'uncompress' => \$uncompress,   # Compress files (decrypt phase).
    'no-recurse' => \$norecurse,    # Don't encrypt/decrypt files in subdirectories.
    'no-delete'  => \$no_delete,    # Don't delete files once they have
                                    # been encrypted.
    'version'    => \$printver,     # Print version
    'help'       => \$help          # Print help
));
&usage_and_exit() if $help;

print " .. gpgdir version: $version by Michael Rash " .
    "<mbr\@cipherdyne.org>\n" and exit 0 if $printver;

if ($decrypt_dir && $encrypt_dir) {
    die " ** You cannot encrypt and decrypt the same directory.\n";
    &usage_and_exit();
}

unless ($decrypt_dir || $encrypt_dir) {
    print " ** Please specify a directory to encrypt or decrypt.\n";
    &usage_and_exit();
}

if ($encrypt_dir && $uncompress) {
    print " ** The --uncompress option is only compatible with --decrypt.\n";
    &usage_and_exit();
}

if ($decrypt_dir && $compress) {
    print " ** The --compress option is only compatible with --encrypt.\n";
    &usage_and_exit();
}

my $gpg = new GnuPG(homedir=>$gpg_homedir);

die " ** Could not create new gpg object with " .
    "homedir: $gpg_homedir" unless $gpg;

if ($encrypt_dir) {
    $dir = $encrypt_dir;
    $dir =~ s|/$||;  ### remove any trailing slash
    $encrypt = 1;
} elsif ($decrypt_dir) {
    ### get the password without echoing the chars back to the screen
    $dir = $decrypt_dir;
    $dir =~ s|/$||;  ### remove any trailing slash
    ReadMode 'noecho';
    while (! $pw) {
        print " .. Enter a password to decrypt $dir: ";
        $pw = ReadLine 0;
        chomp $pw;
    }
    ReadMode 'normal';
    print "\n";
    $encrypt = 0;
}

my $initial_dir = cwd;

if ($dir !~ m|^/|) {
    $dir = $initial_dir . '/' . $dir;
}

unless ($norecurse) {
    ### find all subdirectories of $dir
    find(\&find_subdirs, $dir);
    for my $subdir (@subdirs) {
        ### perform the encrypt/decrypt operation on the directory
        &gpg_operation($subdir);
    }
} else {
    ### perform the encrypt/decrypt operation on the directory
    &gpg_operation($dir);
}

if ($encrypt) {
    print " .. Total number of files encrypted: " .
        "$total_encrypted\n";
} else {
    print " .. Total number of files decrypted: " .
        "$total_decrypted\n";
}
print " .. Finished.\n";

exit 0;
#==================== end main =====================

sub gpg_operation() {
    my $dir = shift;
    my @errs;
    die " .. Directory: $dir does not exist.\n" unless -d $dir;

    if ($dir =~ m|\.gnupg|) {  ### don't encrypt any .gnupg directories!!!
        print " ** Skipping directory: $dir\n";
        return;
    }
    chdir $dir or die " ** Could not chdir: $dir\n";
    opendir D, '.' or die " ** Could not open $dir";
    my @files = readdir D;
    closedir D;

    shift @files; shift @files;

    if ($encrypt) {
        print " .. ==> Encrypting <==  $dir\n";
    } else {
        print " .. ==> Decrypting <==  $dir\n";
    }

    my %errs;
    FILE: for my $file (@files) {
        next FILE unless $file =~ /\S/ && -e $file;
        if (-l $file) {
            $errs{'link'}{'ctr'}++;
            $errs{'link'}{'msg'} = 'file is a link';
            next FILE;
        } elsif (-d $file) {
            $errs{'directory'}{'ctr'}++;
            $errs{'directory'}{'msg'} = 'directory skip';
            next FILE;
        } elsif (-s $file == 0) {
            $errs{'zero'}{'ctr'}++;
            $errs{'zero'}{'msg'} = 'zero byte file';
            next FILE;
        } elsif ($file =~ m|^\.|) {  ### don't encrypt hidden files
            $errs{'hidden'}{'ctr'}++;
            $errs{'hidden'}{'msg'} = 'hidden file';
            next FILE;
        }
        if ($encrypt) {
            ### NOTE: encrypted files cannot be modified, so go ahead and
            ### encrypt $file over any existing $file.gpg encrypted file.
            if ($file =~ /\.gpg$/) {
                $errs{'encrypted'}{'ctr'}++;
                $errs{'encrypted'}{'msg'} = 'previously encrypted';
            } else {
                my $compressed = 0;
                if ($compress) {
                    unless ($file =~ m|\.gz$|) {
                        print " .. Compressing:  $file\n";
                        system "$gzipCmd $file";
                        if (-e "${file}.gz") {
                            $compressed = 1;
                            $file = "${file}.gz";
                        } else {
                            $errs{'bad_compress'}{'ctr'}++;
                            $errs{'bad_compress'}{'msg'} = 'failed compress';
                            next FILE;
                        }
                    }
                }
                print " .. Encrypting:  $file\n" .
                $gpg->encrypt(plaintext=>$file, output=>"${file}.gpg",
                              recipient=>$encrypt_user);
                if (-e "${file}.gpg" && -s "${file}.gpg" != 0) {
                    $total_encrypted++;
                    ### only delete the original file if
                    ### the encrypted one exists
                    unlink $file unless $no_delete;
                } else {
                    $errs{'bad_encrypt'}{'ctr'}++;
                    $errs{'bad_encrypt'}{'msg'} = 'failed encrypt';
                }
            }
        } else {
            my ($filename) = ($file =~ /^(\S+)\.gpg$/);
            next unless $filename;
            if (-e $filename) {
                $errs{'decrypted'}{'ctr'}++;
                $errs{'decrypted'}{'msg'} = 'previously decrypted';
            } else {
                ### don't decrypt a file on top of a normal file of
                ### the same name
                print " .. Decrypting:  $file\n";
                $gpg->decrypt(ciphertext=>$file, output=>$filename,
                              passphrase=>$pw);
                if (-e $filename && -s $filename != 0) {
                    ### only delete the original encrypted
                    ### file if the decrypted one exists
                    unlink $file;
                    $total_decrypted++;
                    if ($uncompress && $filename =~ /(\S+)\.gz/) {
                        my $ufile = $1;
                        print " .. Uncompressing:  $filename\n";
                        system "$gunzipCmd $filename";
                        unless (-e $ufile) {
                            $errs{'bad_gunzip'}{'ctr'}++;
                            $errs{'bad_gunzip'}{'msg'} = 'failed gunzip';
                        }
                    }
                } else {
                    $errs{'bad_decrypt'}{'ctr'}++;
                    $errs{'bad_decrypt'}{'msg'} = 'failed decrypt';
                }
            }
        }
    }
    if (%errs) {
        print " .. Errors/Warnings:\n";
        for my $problem (keys %errs) {
            print " ** Error: \"$errs{$problem}{'msg'}\", ",
                "Count: $errs{$problem}{'ctr'}\n";
        }
    }
    print "\n";
    chdir $initial_dir or die " ** Could not chdir: $initial_dir\n";
    return;
}

sub get_homedir() {
    my $uid = $<;
    open P, "< /etc/passwd" or die " ** Could not open /etc/passwd.  " .
        "Exiting.\n";
    my @lines = <P>;
    close P;
    my $homedir = '';
    for my $line (@lines) {
        ### mbr:x:222:222:Michael Rash:/home/mbr:/bin/bash
        chomp $line;
        if ($line =~ /^(?:.*:){2}$uid:(?:.*:){2}(\S+):/) {
            $homedir = $1;
            last;
        }
    }
    die " ** Could not extract homedir from /etc/passwd for " .
        "uid: $uid.  Exiting.\n" unless $homedir;
    die " ** homedir: $homedir does not exist.  " .
        "Exiting.\n" unless -d $homedir;
    return $homedir;
}

sub get_key() {
    if (-e "${homedir}/.gpgdirrc") {
        open F, "< ${homedir}/.gpgdirrc" or die " .. Could not open " .
            "${homedir}/.gpgdirrc.  Exiting.\n";
        my @lines = <F>;
        close F;
        my $key = '';
        for my $line (@lines) {
            chomp $line;
            if ($line =~ /^use_key\s+(\w{8})$/) {
                $key = $1;
                last;
            }
        }
        if ($key && $key =~ /\S/) {
            return $key;
        } else {
            print " ** Please edit ${homedir}/.gpgdirrc to include your gpg key",
                "    identifier (e.g. \"D4696445\").  See the output of ",
                "\"gpg --list-keys\"\n";
            exit 1;
        }
    } else {
        print " .. Creating gpgdir rc file: ${homedir}/.gpgdirrc\n";
        open F, "> ${homedir}/.gpgdirrc" or die " .. Could not open " .
            "${homedir}/.gpgdirrc.  Exiting.\n";
        print F "# Config file for gpgdir.\n";
        print F "# Set the key to use to encrypt files with\n";
        print F "# \"use_key <key>\", e.g. \"use_key D4696445\".\n";
        print F "# See \"gpg --list-keys\" for a list of keys.\n";
        print F "\n";
        print F "# Uncomment and replace \"KEYID\" with your real " .
            "key id on the next line:\n";
        print F "#use_key KEYID\n";
        close F;
        print " ** Please edit ${homedir}/.gpgdirrc to include " .
            "your gpg key identifier.  Exiting.\n";
        exit 1;
    }
    return;
}

sub find_subdirs() {
    my $file = $File::Find::name;
    if (-d $file && -e $file) {
        push @subdirs, $file;
    }
    return;
}

sub usage_and_exit() {
    print <<_HELP_;
gpgdir
    version: $version, by Michael Rash (mbr\@cipherdyne.org)

Usage: gpgdir [-e <directory>] [-d <directory>] [-c] [-u] [-n] [-v] [-h]

Options:
   -e, --encrypt <directory>
   -d, --decrypt <directory>
   -c, --compress   - Compress files when running in --encrypt mode.
   -u, --uncompress - Uncompress files when running in --decrypt mode.
   -n, --no-recurse - Don't recursively encrypt/decrypt subdirectories.
   -v, --version    - print version.
   -h, --help       - print help.
_HELP_
    exit 0;
}
